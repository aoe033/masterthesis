%location/filename: tex/fig/ap4.tex
%author: Anders Ã˜stevik
%Last edited: 24.05.2016
%#######--Appendix - Software Non-standard libraries--#######
%

\documentclass[main.tex]{subfiles}

\begin{document}

\chapter{Non-standard C-Libraries} \label{chap:clibs}

The serial communications software was developed with the help of a few non-standard libraries; non-standard meaning that the libraries are not a part of the C standard libraries. In addition, the "Signals" library was written, which is dedicated to hold the \gls{gbt} control-signal information.
The following sections gives brief descriptions of each of these libraries and the associated functions used in the serial communications software:

\section{RS232} \label{sec:rs232}

The RS232 library (\textit{rs232.h} and \textit{rs232.c}) is a cross-platform C-library for sending and receiving bytes from the \gls{com} of a \acrshort{pc}. It was written by Teunis van Beelen, and is licensed under the "GPL version 3" licence \cite{gpl3}. The library compiles with GCC on Linux and Mingw-w64 on Windows. By specifying baud rate, the name of the relevant \gls{com}, and the transmission mode (8N1 is standard), the library provides access to the \gls{com} and allows for both reading and writing to it. For more information about the library and functions, visit \url{http://www.teuniz.net/RS-232/#}.

\subsection{Associated functions}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\begin{lstlisting}[frame=single] 
int RS232_OpenComport(int comport_number, int baudrate, const char * mode)
\end{lstlisting}
Opens the \gls{com}. The user must specify a \gls{com} number, a baudrate number and the transmission mode (see list of valid inputs in \textit{rs232.c}). It is important that the user grants super-user/administration priveliges to the program, or it might not be able to open the \gls{com} or change the baudrate correctly. The function returns 1 if it does not succeed in opening the \gls{com}.\\

\begin{lstlisting}[frame=single] 
int RS232_PollComport(int comport_number, unsigned char *buf, int size)
\end{lstlisting}
Returns the amount of bytes (in integers) received from the \gls{com}. The received bytes are stored in a buffer and pointed to by \textit{buf}. One must specify the \textit{size} of the buf pointer. It is recommended to call this function routinely from a timer.\\

\begin{lstlisting}[frame=single] 
int RS232_SendBuf(int comport_number, unsigned char *buf,int size)
\end{lstlisting}
Sends a buffer of bytes via the \gls{com}. The \textit{buf} pointer must point to an array of bytes, and \textit{size} must specify the correct size of the array pointed to by the \textit{buf}.\\

\begin{lstlisting}[frame=single] 
void RS232_CloseComport(int comport_number)
\end{lstlisting}
Closes the \gls{com}. To prevent errors, it is important to disable any timers that calls \gls{com} related functions before closing the \gls{com}.\\

\section{Timer} \label{sec:timer}

The Timer library (\textit{timer.h} and \textit{timer.c}) is a library for handling timers in a C environment. It was written by Teunis van Beelen, and is licensed under the "GPL version 3" licence \cite{gpl3}. The accuracy of the timer is system dependent. It supports a resolution down to $1~\milli\second$ on the Windows platform and a resolution down to $1~\micro\second$ on the Linux platform (though, in real-life situations, the timer might not be as accurate). The timer function is used with the \textit{RS232\_PollComport}-function in mind (see function definition above). For more information about the library and functions, visit \url{http://www.teuniz.net/RS-232/#}.

\subsection{Associated functions}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\begin{lstlisting}[frame=single] 
int start_timer(int milliSeconds, void (*)(void))
\end{lstlisting}
Starts the timer. At a given time interval of \textit{milliSeconds} (milliseconds in Windows, microseconds in Linux), it calls a given function. The call-function must be a void function with no inputs (just like a standard main function without the argument calls). The \textit{start\_timer} function are called only ones in main, and repeats calling the given function every \textit{milliSeconds} interval until the \textit{stop\_timer} is called.\\

\begin{lstlisting}[frame=single] 
int stop_timer( void )
\end{lstlisting}
Stops the timer if \textit{start\_timer} has previously been called. If the timer routinely calls RS232-functions, \textit{stop\_timer} must be called before closing the \gls{com} at the end of the program to prevent errors.

\section{Signals} \label{sec:signals}

The Signals library (\textit{signals.h} and \textit{signals.c}) was written with the \gls{gbt} control-signals in mind. It features methods for storing and manipulating the control-signal information, and in some extent encapsulates the information by partly hiding the information from the user. This is done by defining the main information-structure inside the \textit{signals.c}-file, instead of defining it in the header file (and thus exposing it to the main program). A dedicated pointer is used to point to the structures namespace, and the functions defined in the header file calls the pointer as input instead of the structure itself. The main program only have access to what is defined in the header, thus limiting the user to only have access to the structure through dedicated library functions.

\subsection{Associated structures}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\begin{lstlisting}[frame=single] 
typedef struct {
  char *name;
  char *index;
  Byte type : 1;
} Type;

 struct _Signal {
  Type type;
  int i; 
  Byte data; 
};
\end{lstlisting}

The \textit{Type}-structure contains the signal name and index in string-form, and a 1-bit type variable that defines the signal as either a probe (0) or a switch (1). \textit{\_Signal}-structure is the main structure and contains the \textit{Type}-structure along with a "real" index, i, which is the actual data-address used to access the correct register-address on the \gls{fpga}; and the data byte, data, which stores the data bit of the signal. If the structure is defined as a probe, the data can only be read from the \gls{fpga}. If it is defined as a switch, on the other hand, it can be both read from the \gls{fpga} or the main program can write data to the \gls{fpga}.

\subsection{Associated functions}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize, % basic font setting
    morekeywords={Signal, _Signal, Byte} 
}

\begin{lstlisting}[frame=single] 
Signal Signal_New (void)
\end{lstlisting}
Assigns a new pointer to the \textit{\_Signal}-structure and allocates enough memory.\\

\begin{lstlisting}[frame=single] 
Signal Signal_Init(char *index, char *name, Byte data)
\end{lstlisting}
Uses \textit{Signal\_New} to define a new signal, and in addition assigns values to the signal variables. The \textit{index} string must contain either an \textit{'S'} or a \textit{'P'} character followed by two number-characters. This is to indicate that the signal is either a probe or a switch with a given register address, for example: "P00", "S35".\\ 
The first letter is used to assign the \textit{type}-variable and the two number-characters are converted to an integer and assigned to the "real" index, i, of the structure. The \textit{name} string should contain a descriptive name of the signal, for example: "TX\_FRAMECLK PHASE ALIGNER - PLL LOCKED".\\

\begin{lstlisting}[frame=single] 
void Signal_InitFromFile(Signal s[], int width, char *filename)
\end{lstlisting}
Uses \textit{Signal\_Init} to define a signal-array using information given from a file. The array has a width given by the \textit{width}-variable. Refer to \textit{signal\_probe.txt} or \textit{signal\_switch.txt} for examples on how to set up a text-file. In the program, the \textit{Signal\_InitFromFile}-function is used twice to define two signal-arrays; one for the \textit{Switches} and one for the \textit{Probes} of the \gls{gbt} control-signals. Defining two signal-arrays makes it more convenient when separating what is writeable and what is read-only.\\

\begin{lstlisting}[frame=single] 
void Signal_Free(Signal s)
\end{lstlisting}
Frees the given signal-pointer and all the associated variables.\\

\begin{lstlisting}[frame=single] 
void Signal_FreeArray(Signal *s, int n)
\end{lstlisting}
Uses \textit{Signal\_Free} in a loop to free up an array of signal-pointers.\\

\begin{lstlisting}[frame=single] 
int Signal_PrintSet(WINDOW *win, int *gy, Signal s[], int width)
\end{lstlisting}
Prints out all printable signal information of a signal-array to a \textit{curses}-window (see section \ref{sec:ncurses}) with a row-position given by \textit{gy}. \textit{gy} is defined as a pointer because it reports back to the program on which line in the window the information is printed on. \\

\begin{lstlisting}[frame=single] 
void Signal_setData(Signal s, Byte value)
Byte Signal_getData(Signal s)
\end{lstlisting}
Functions related to reading and writing to the data-variable, data, of a given signal.\\

\begin{lstlisting}[frame=single] 
void Signal_setIndex(Signal s, int i)
int Signal_getIndex(Signal s)
\end{lstlisting}
Functions related to reading and writing to the "real" index-variable, \textit{i}, of a given signal.\\

\begin{lstlisting}[frame=single] 
void Signal_setType(Signal s, Byte type, char *name, char *index)
void Signal_getType(Signal s, Byte *type, char *name, char *index)
\end{lstlisting}
Functions related to reading and writing to the \textit{Type}-structure of a given signal.\\

\begin{lstlisting}[frame=single] 
void Signal_setTypeType(Signal s, Byte type)
Byte Signal_getTypeType(Signal s)
\end{lstlisting}
Functions related to reading and writing to the type-variable, \textit{type}, of the \textit{Type}-structure of a given signal.\\

\begin{lstlisting}[frame=single] 
void Signal_setTypeName(Signal s, char *name)
char *Signal_getTypeName(Signal s)
\end{lstlisting}
Functions related to reading and writing to the name string, \textit{name}, of the \textit{Type}-structure of a given signal.\\

\begin{lstlisting}[frame=single] 
void Signal_setTypeIndex(Signal s, char *name)
char *Signal_getTypeIndex(Signal s)
\end{lstlisting}
Functions related to reading and writing to the index string, \textit{index}, of the \textit{Type}-structure of a given signal.

\section{ncurses} \label{sec:ncurses}

The ncurses library is a terminal control library commonly used with Unix-systems. It is "freely redistributable in source form" \cite{ncursesdoc}, and enables you to construct interfaces using the terminal as the base. The main purpose of using ncurses for the \gls{gbt} software interface was to enable multiple windows; one window to continuously update and display the \gls{gbt} control signals, and another window for the user to write commands. To compile ncurses-based programs in Windows, one can use the \textit{pdcurses} library. The \textit{pdcurses} library has the same function names and overall functionality, so no alterations of code is needed. The following library and function information has been taken from \url{http://linux.die.net/man/}, which is a website collection of Linux-related documentation (ncurses is integrated into the Linux system). 

\subsection{Associated functions - Initialization}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize, % basic font setting
    morekeywords={WINDOW} 
}

\begin{lstlisting}[frame=single] 
WINDOW *initscr(void);
\end{lstlisting}
Initialization function that sets up a new ncurses window. This needs to be called once, and before any other ncurses related function.\\

\begin{lstlisting}[frame=single] 
int noecho(void)
\end{lstlisting}
Disables the user input from being printed back on screen, i.e being echoed.  \\

\begin{lstlisting}[frame=single] 
int cbreak(void)
\end{lstlisting}
Disables line buffering, making characters typed by the user available to the program one-by-one.\\

\begin{lstlisting}[frame=single] 
int keypad(WINDOW *win, bool bf)
\end{lstlisting}
Function that, when \textbf{TRUE}, allows the program to capture special keys using the function \textit{getch()}, like \textit{backspace} and the arrow keys. In the GBT serial interface, \textit{win} is defined as \textit{stdscr}, which is the main terminal screen. \\

\begin{lstlisting}[frame=single] 
int nodelay(WINDOW *win, bool bf)
\end{lstlisting}
Function that keeps the input capture function, \textit{getch()}, from blocking the program when no input has been received. When \textit{bf} is \textbf{TRUE}, getch() will return \textbf{ERR} instead of waiting for a key to be pressed. This function was necessary to allow one window to update freely while another window handled input. \textit{win} is defined as \textit{stdscr}.\\

\begin{lstlisting}[frame=single] 
void getmaxyx(WINDOW *win, int y, int x)
\end{lstlisting}
Function that store the current beginning coordinates and size of the specified window. In the case of the GBT software interface, \textit{win} is specified as the main terminal screen, \textit{stdscr}. These coordinates are needed when adding individual windows inside \textit{stdscr}. \\

\begin{lstlisting}[frame=single] 
WINDOW *newwin(int nlines, int ncols, int begin_y, int begin_x)
\end{lstlisting}
Function used to initiate a new window within the main terminal screen, \textit{stdscr}, where \textit{nlines} a \textit{ncols} is the number of lines and columns the window is to contain, and \textit{begin\_y} and \textit{begin\_x} is the upper left hand corner of the window. This function is used to initiate the three windows, "Command History", "Commandline" and "Signals" in the GBT serial interface.\\

\begin{lstlisting}[frame=single] 
int scrollok(WINDOW *win, bool bf)
\end{lstlisting}
Function that, if \textbf{TRUE}, enables scrolling of typed in characters, either by using the additional \textit{scroll}-function, or when the cursor reached the last column of the last line in the specified window \textit{win}. This function is only used with the "Command History" window to scroll commands that are read in.\\

\begin{lstlisting}[frame=single] 
int leaveok(WINDOW *win, bool bf)
\end{lstlisting}
Function to disable the cursor at the specified window. It is used to disable the cursor in the "Command History" and "Signals" windows in the GBT serial interface.  

\subsection{Associated functions - Various}

\begin{lstlisting}[frame=single] 
int wresize(WINDOW *win, int lines, int columns)
\end{lstlisting}
Enables for resizing of the initiated windows. \\

\begin{lstlisting}[frame=single] 
int wclear(WINDOW *win)
\end{lstlisting}
Clears the specified window of its content. \\

\begin{lstlisting}[frame=single] 
int mvwprintw(WINDOW *win, int y, int x, const char *fmt, ...)
\end{lstlisting}
Analogous to the printf routine, found in the C standard library. However, this allows to print output in a specified window with coordinates. \textit{mvwprintw} is used when printing information out on the different windows. \\

\begin{lstlisting}[frame=single] 
int wrefresh(WINDOW *win)
\end{lstlisting}
Function to update the individual windows. This function must be called to get actual output to the terminal, preferably at the end of the main loop. \\

\begin{lstlisting}[frame=single] 
int wmove(WINDOW *win, int y, int x)
\end{lstlisting}
Function that allows for repositioning of the cursor at the specified window. This function is called to reposition the cursor in the "Commandline" at the end of an input string.

\end{document}
